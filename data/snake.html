<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Snake — one-file edition</title>
<style>
  html,body{margin:0;height:100%;background:#000;display:flex;justify-content:center;align-items:center;font-family:sans-serif;color:#0f0}
  canvas{background:#111;box-shadow:0 0 12px #0f0}
  #overlay{position:absolute;top:0;left:0;right:0;bottom:0;display:flex;flex-direction:column;justify-content:center;align-items:center;background:rgba(0,0,0,.8);font-size:2rem;visibility:hidden}
  #overlay button{margin-top:1rem;padding:.5rem 1.2rem;font-size:1rem;border:none;border-radius:6px;background:#0f0;color:#000;cursor:pointer}
</style>
</head>
<body>
<canvas id="game" width="640" height="480"></canvas>
<div id="overlay">
  <span id="message"></span>
  <button onclick="resetGame()">Play again</button>
</div>

<script>
(() => {
  // ╭─ configuration
  const SIZE = 20;                 // size of one cell in px
  const SPEED_START = 120;         // ms between frames at start
  const SPEED_STEP  = 4;           // ms faster after each apple
  const COLS = 32, ROWS = 24;      // 640×480 / SIZE
  // ╰──────────────────────────────
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const overlay = document.getElementById('overlay');
  const msg = document.getElementById('message');

  let snake, dir, nextDir, apple, speed, tickId, score;

  const DIRS = {ArrowUp:[0,-1],ArrowDown:[0,1],ArrowLeft:[-1,0],ArrowRight:[1,0]};
  window.addEventListener('keydown', e=>{
    if(DIRS[e.key]){
      const [dx,dy]=DIRS[e.key], [cx,cy]=DIRS[dir];
      // prevent reversing
      if(dx!==-cx || dy!==-cy) nextDir = e.key;
    } else if(e.key===' ' && !tickId) resetGame();
  });

  function resetGame(){
    snake=[[16,12],[15,12],[14,12]];
    dir='ArrowRight'; nextDir=dir;
    placeApple();
    speed=SPEED_START;
    score=0;
    overlay.style.visibility='hidden';
    clearInterval(tickId);
    tickId=setInterval(update,speed);
  }

  function placeApple(){
    do{
      apple=[randInt(COLS),randInt(ROWS)];
    }while(snake.some(([x,y])=>x===apple[0]&&y===apple[1]));
  }

  function update(){
    dir=nextDir;
    const head=[snake[0][0]+DIRS[dir][0], snake[0][1]+DIRS[dir][1]];
    // collision?
    if(head[0]<0||head[0]>=COLS||head[1]<0||head[1]>=ROWS||
       snake.some(([x,y])=>x===head[0]&&y===head[1])){
      gameOver();
      return;
    }
    snake.unshift(head);
    if(head[0]===apple[0]&&head[1]===apple[1]){
      score++;
      speed=Math.max(40,speed-SPEED_STEP);
      clearInterval(tickId);
      tickId=setInterval(update,speed);
      placeApple();
    }else snake.pop();
    draw();
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // grid (optional, comment out to hide)
    /* ctx.strokeStyle='#222';
       for(let x=0;x<=COLS;x++) ctx.strokeRect(x*SIZE,0,1,canvas.height);
       for(let y=0;y<=ROWS;y++) ctx.strokeRect(0,y*SIZE,canvas.width,1); */
    // apple
    ctx.fillStyle='#f00';
    roundRect(apple[0]*SIZE,apple[1]*SIZE,SIZE,SIZE,4);
    // snake
    ctx.fillStyle='#0f0';
    snake.forEach(([x,y],i)=>{
      const r=i?2:4;
      roundRect(x*SIZE,y*SIZE,SIZE,SIZE,r);
    });
    // score
    ctx.fillStyle='#0f0';
    ctx.font='16px monospace';
    ctx.fillText('Score: '+score,8,20);
  }

  function gameOver(){
    clearInterval(tickId); tickId=null;
    msg.textContent=`Game over — score ${score}`;
    overlay.style.visibility='visible';
  }

  function randInt(max){return Math.floor(Math.random()*max);}
  function roundRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.lineTo(x+w-r,y);
    ctx.quadraticCurveTo(x+w,y,x+w,y+r);
    ctx.lineTo(x+w,y+h-r);
    ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
    ctx.lineTo(x+r,y+h);
    ctx.quadraticCurveTo(x,y+h,x,y+h-r);
    ctx.lineTo(x,y+r);
    ctx.quadraticCurveTo(x,y,x+r,y);
    ctx.fill();
  }

  resetGame();     // start immediately
})();
</script>
</body>
</html>
